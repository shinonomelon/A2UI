{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"a2ui_protocol/","title":"A2UI (Agent to UI) Protocol","text":"<p>A Specification for a JSONL-Based, Streaming UI Protocol</p> <p>Created: Sep 19, 2025</p>"},{"location":"a2ui_protocol/#design-requirements","title":"Design Requirements","text":"<p>The A2UI (Agent to UI) protocol should be a system where an LLM can stream a platform-agnostic, abstract UI definition to a client, which then renders it progressively using a native widget set. Every major design choice is traced back to the core challenges of LLM generation, perceived performance, and platform independence.</p>"},{"location":"a2ui_protocol/#requirement-the-protocol-must-be-easily-generated-by-a-transformer-large-language-model-llm","title":"Requirement: The protocol must be easily generated by a Transformer Large Language Model (LLM)","text":"<p>This is the most critical driver. This requirement directly leads to several design choices:</p> <p>Declarative, Simple Structure: The protocol should use a straightforward, declarative format (\"this is a column with these children\") rather than an imperative one (\"now, add a column; then, append a text widget to it\"). LLMs excel at generating structured, declarative data.</p> <p>Flat Component List (Adjacency List): Requiring an LLM to generate a perfectly nested JSON tree in a single pass is difficult and error-prone. A flat list of components, where relationships are defined by simple string IDs, is much easier to generate piece by piece. The model can \"think\" of a component, give it an ID, and then reference that ID later without worrying about tree depth or object nesting.</p> <p>Stateless Messages: Each JSONL message is a self-contained unit of information (componentUpdate, dataModelUpdate). This is ideal for a streaming LLM, which can output these messages incrementally as it processes a request.</p>"},{"location":"a2ui_protocol/#requirement-the-ui-must-render-progressively-for-a-fast-responsive-user-experience","title":"Requirement: The UI must render progressively for a fast, responsive user experience","text":"<p>The system must feel fast to the user, even if the full UI is complex and takes time to generate.</p> <p>Streaming via JSONL/SSE: This is a direct solution. The client doesn't have to wait for a single, massive JSON payload. It can start receiving and processing UI components immediately, improving perceived performance.</p>"},{"location":"a2ui_protocol/#requirement-the-protocol-must-be-platform-agnostic","title":"Requirement: The protocol must be platform-agnostic","text":"<p>The same server-side logic should be able to render a UI on a Flutter app, a web browser, or potentially other platforms without modification.</p> <p>Client-Defined widget catalog: This is the core of the platform-agnostic design. The protocol should define an abstract component tree (e.g., \"I need a Card with a Row inside\"). It is the client's responsibility to map these abstract types to its native widget implementations (a Flutter Card widget, an HTML <code>&lt;div&gt;</code> with card styling, etc.). The server only needs to know the names of the components the client supports.</p>"},{"location":"a2ui_protocol/#requirement-state-management-must-be-efficient-and-decoupled-from-the-ui-structure","title":"Requirement: State management must be efficient and decoupled from the UI structure","text":"<p>Changing a piece of text in the UI should not require resending the entire UI definition.</p> <p>Separation of Data and Components: Having distinct componentUpdate and data model update messages is key. The UI structure can be sent once, and subsequent updates can be small dataModelUpdate messages that only contain the changed data.</p>"},{"location":"a2ui_protocol/#requirement-the-communication-architecture-must-be-robust-and-scalable","title":"Requirement: The communication architecture must be robust and scalable","text":"<p>The system needs a clear, reliable way to handle both server-pushed UI and client-initiated events.</p> <p>Unidirectional UI Stream: Using a one-way stream (SSE) for UI updates simplifies the client's logic. It only needs to listen and react. This is a more robust pattern for server-push than trying to manage a complex bidirectional channel.</p> <p>Event Handling: Event handling is done via an A2A message from the client to the server agent</p>"},{"location":"a2ui_protocol/#introduction","title":"Introduction","text":"<p>The A2UI Protocol is a protocol designed for rendering user interfaces from a stream of JSON objects sent from a server. Its core philosophy emphasizes a clean separation of UI structure and application data, enabling progressive rendering as the client processes each message.</p> <p>The protocol is designed to be \"LLM-friendly,\" meaning its structure is declarative and straightforward, making it easy for a generative model to produce.</p> <p>Communication occurs via a JSON Lines (JSONL) stream. The client parses each line as a distinct message and incrementally builds the UI. The server-to-client protocol defines four message types:</p> <ul> <li><code>surfaceUpdate</code>: Provides a list of component definitions to be added to or updated in a specific UI area called a \"surface.\"</li> <li><code>dataModelUpdate</code>: Provides new data to be inserted into or to replace a surface's data model. Each surface has its own data model.</li> <li><code>beginRendering</code>: Signals to the client that it has enough information to perform the initial render, specifying the ID of the root component.</li> <li><code>deleteSurface</code>: Explicitly removes a surface and its contents from the UI.</li> </ul> <p>Client-to-server communication for user interactions is handled separately via a JSON payload sent to a REST API. This message can be one of several types:</p> <ul> <li><code>userAction</code>: Reports a user-initiated action from a component.</li> <li><code>clientUiCapabilities</code>: Informs the server about the client's capabilities, such as the component catalog it supports.</li> <li><code>error</code>: Reports a client-side error.   This keeps the primary data stream unidirectional.</li> </ul>"},{"location":"a2ui_protocol/#section-1-foundational-architecture-and-data-flow","title":"Section 1: Foundational Architecture and Data Flow","text":"<p>This document specifies the architecture and data formats for the A2UI protocol. The design is guided by principles of strict separation of concerns, versioning, and progressive rendering.</p>"},{"location":"a2ui_protocol/#11-core-philosophy-decoupling-and-contracts","title":"1.1. Core Philosophy: Decoupling and Contracts","text":"<p>The central philosophy of A2UI is the decoupling of three key elements:</p> <ol> <li>The Component Tree (The Structure): A server-provided tree of abstract components that describes the UI's structure. This is defined by <code>componentUpdate</code> messages.</li> <li>The Data Model (The State): A server-provided JSON object containing the dynamic values that populate the UI, such as text, booleans, or lists. This is managed via <code>dataModelUpdate</code> messages.</li> <li>The Widget Registry (The \"Catalog\"): A client-defined mapping of component types (e.g., \"Row\", \"Text\") to concrete, native widget implementations. This registry is part of the client application, not the protocol stream. The server must generate components that the target client's registry understands.</li> </ol>"},{"location":"a2ui_protocol/#12-the-jsonl-stream-the-unit-of-communication","title":"1.2. The JSONL Stream: The Unit of Communication","text":"<p>All UI descriptions are transmitted from the server to the client as a stream of JSON objects, formatted as JSON Lines (JSONL). Each line is a separate, compact JSON object representing a single message. This allows the client to parse and process each part of the UI definition as it arrives, enabling progressive rendering.</p>"},{"location":"a2ui_protocol/#13-surfaces-managing-multiple-ui-regions","title":"1.3. Surfaces: Managing Multiple UI Regions","text":"<p>A Surface is a contiguous portion of screen real estate into which a A2UI UI can be rendered. The protocol introduces the concept of a <code>surfaceId</code> to uniquely identify and manage these areas. This allows a single A2UI stream to control multiple, independent UI regions simultaneously. Each surface has a separate root component and a separate hierarchy of components. Each surface has a separate data model, to avoid collision of keys when working with a large number of surfaces.</p> <p>For example, in a chat application, each AI-generated response could be rendered into a separate surface within the conversation history. A separate, persistent surface could be used for a side panel that displays related information.</p> <p>The <code>surfaceId</code> is a property within each server-to-client message that directs changes to the correct area. It is used with messages like <code>beginRendering</code>, <code>surfaceUpdate</code>, <code>dataModelUpdate</code>, and <code>deleteSurface</code> to target a specific surface.</p>"},{"location":"a2ui_protocol/#14-data-flow-model","title":"1.4. Data Flow Model","text":"<p>The A2UI protocol is composed of a server-to-client stream describing UI and individual events sent to the server. The client consumes the stream, builds the UI, and renders it. Communication occurs via a JSON Lines (JSONL) stream, typically transported over Server-Sent Events (SSE).</p> <ol> <li>Server Stream: The server begins sending the JSONL stream over an SSE connection.</li> <li> <p>Client-Side Buffering: The client receives messages and buffers them:</p> <ul> <li><code>surfaceUpdate</code>: Component definitions are stored in a <code>Map&lt;String, Component&gt;</code>, organized by <code>surfaceId</code>. If a surface doesn't exist, it is created.</li> <li><code>dataModelUpdate</code>: The client's internal JSON data model is built or updated.</li> </ul> </li> <li> <p>Render Signal: The server sends a <code>beginRendering</code> message with the <code>root</code> component's ID. This prevents a \"flash of incomplete content.\" The client buffers incoming components and data but waits for this explicit signal before attempting the first render, ensuring the initial view is coherent.</p> </li> <li>Client-Side Rendering: The client, now in a \"ready\" state, starts at the <code>root</code> component. It recursively walks the component tree by looking up component IDs in its buffer. It resolves any data bindings against the data model and uses its <code>WidgetRegistry</code> to instantiate native widgets.</li> <li>User Interaction and Event Handling: The user interacts with a rendered widget (e.g., taps a button). The client constructs a <code>userAction</code> JSON payload, resolving any data bindings from the component's <code>action.context</code>. It sends this payload to the server via an A2A message.</li> <li>Dynamic Updates: The server processes the <code>userAction</code>. If the UI needs to change in response, the server sends new <code>surfaceUpdate</code> and <code>dataModelUpdate</code> messages over the original SSE stream. As these arrive, the client updates its component buffer and data model, and the UI re-renders to reflect the changes. The server can also send <code>deleteSurface</code> to remove a UI region.</li> </ol> <pre><code>sequenceDiagram\n    participant Server\n    participant Client\n\n    Server-&gt;&gt;+Client: SSE Connection (JSONL Stream)\n    Client-&gt;&gt;Client: 1. Parse JSONL message\n    loop Until 'beginRendering'\n        Client-&gt;&gt;Client: 2a. Process surfaceUpdate\n        Client-&gt;&gt;Client: 2b. Process dataModelUpdate\n    end\n    Client-&gt;&gt;Client: 3. Process beginRendering (rootId: 'root', isReady: true)\n    Note right of Client: 4. Triggers UI build for a surface\n    Client-&gt;&gt;Client: 5. Build widget tree from 'root'\n    Client-&gt;&gt;Client: 6. Resolve data bindings\n    Client-&gt;&gt;Client: 7. Look up widgets in WidgetRegistry\n    Client--&gt;&gt;-Server: (UI is rendered)\n\n    Note over Client: 8. User interacts with UI (e.g., clicks button)\n    Client-&gt;&gt;Client: 9. Construct userAction payload\n    Client-&gt;&gt;+Server: 10. A2A Message sent to server (Client Event JSON with userAction)\n    Server--&gt;&gt;-Client: 11. OK\n\n    loop Dynamic Updates in Response to Event\n        Server-&gt;&gt;+Client: surfaceUpdate, dataModelUpdate, or deleteSurface (via SSE)\n        Client-&gt;&gt;Client: Update component map, data model, or remove surface\n        Note right of Client: Triggers UI rebuild\n        Client--&gt;&gt;-Server: (UI is updated)\n    end</code></pre>"},{"location":"a2ui_protocol/#15-full-stream-example","title":"1.5. Full Stream Example","text":"<p>The following is a complete, minimal example of a JSONL stream that renders a user profile card.</p> <pre><code>{\"surfaceUpdate\": {\"components\": [{\"id\": \"root\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"profile_card\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"profile_card\", \"component\": {\"Card\": {\"child\": \"card_content\"}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"card_content\", \"component\": {\"Column\": {\"children\": {\"explicitList\": [\"header_row\", \"bio_text\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"header_row\", \"component\": {\"Row\": {\"alignment\": \"center\", \"children\": {\"explicitList\": [\"avatar\", \"name_column\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"avatar\", \"component\": {\"Image\": {\"url\": {\"literalString\": \"[https://www.example.com/profile.jpg)\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"name_column\", \"component\": {\"Column\": {\"alignment\": \"start\", \"children\": {\"explicitList\": [\"name_text\", \"handle_text\"]}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"name_text\", \"component\": {\"Heading\": {\"level\": \"3\", \"text\": {\"literalString\": \"Flutter Fan\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"handle_text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"@flutterdev\"}}}}]}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"bio_text\", \"component\": {\"Text\": {\"text\": {\"literalString\": \"Building beautiful apps from a single codebase.\"}}}}]}}\n{\"dataModelUpdate\": {\"contents\": {}}}\n{\"beginRendering\": {\"root\": \"root\"}}\n</code></pre>"},{"location":"a2ui_protocol/#section-2-the-component-model","title":"Section 2: The Component Model","text":"<p>A2UI's component model is designed for flexibility, separating the protocol from the component set.</p>"},{"location":"a2ui_protocol/#21-the-catalog-defining-components","title":"2.1. The Catalog: Defining Components","text":"<p>Unlike previous versions with a fixed component set, A2UI now defines components in a Catalog. A catalog is a schema that defines the available component types (e.g., <code>Row</code>, <code>Text</code>) and their supported properties. This allows for different clients to support different sets of components, including custom ones. The server must generate <code>surfaceUpdate</code> messages that conform to the component catalog understood by the client. Clients can inform the server of the catalog they support using the <code>clientUiCapabilities</code> message.</p>"},{"location":"a2ui_protocol/#22-the-surfaceupdate-message","title":"2.2. The <code>surfaceUpdate</code> Message","text":"<p>This message is the primary way UI structure is defined. It contains a <code>surfaceId</code> and a <code>components</code> array.</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"components\": [\n      {\n        \"id\": \"unique-component-id\",\n        \"component\": {\n          \"Text\": {\n            \"text\": { \"literalString\": \"Hello, World!\" }\n          }\n        }\n      },\n      {\n        \"id\": \"another-component-id\",\n        \"component\": { ... }\n      }\n    ]\n  }\n}\n</code></pre> <ul> <li><code>components</code>: A required flat list of component instances.</li> </ul>"},{"location":"a2ui_protocol/#23-the-component-object","title":"2.3. The Component Object","text":"<p>Each object in the <code>components</code> array has the following structure:</p> <ul> <li><code>id</code>: A required, unique string that identifies this specific component instance. This is used for parent-child references.</li> <li><code>component</code>: A required object that defines the component's type and properties.</li> </ul>"},{"location":"a2ui_protocol/#24component-generic-object","title":"2.4.<code>component</code> (Generic Object)","text":"<p>On the wire, this object is generic. Its structure is not defined by the core A2UI protocol. Instead, its validation is based on the active Catalog. It is a wrapper object that must contain exactly one key, where the key is the string name of the component type from the catalog (e.g., <code>\"Text\"</code>, <code>\"Row\"</code>). The value is an object containing the properties for that component, as defined in the catalog.</p> <p>Example: A <code>Text</code> component:</p> <pre><code>\"component\": {\n  \"Text\": {\n    \"text\": { \"literalString\": \"This is text\" }\n  }\n}\n</code></pre> <p>A <code>Button</code> component:</p> <pre><code>\"component\": {\n  \"Button\": {\n    \"label\": { \"literalString\": \"Click Me\" },\n    \"action\": { \"name\": \"submit_form\" }\n  }\n}\n</code></pre> <p>The full set of available component types and their properties is defined by a Catalog Schema, not in the core protocol schema.</p>"},{"location":"a2ui_protocol/#section-3-ui-composition","title":"Section 3: UI Composition","text":""},{"location":"a2ui_protocol/#31-the-adjacency-list-model","title":"3.1. The Adjacency List Model","text":"<p>The A2UI protocol defines the UI as a flat list of components. The tree structure is built implicitly using ID references. This is known as an adjacency list model.</p> <p>Container components (like <code>Row</code>, <code>Column</code>, <code>List</code>, <code>Card</code>) have properties that reference the <code>id</code> of their child component(s). The client is responsible for storing all components in a map (e.g., <code>Map&lt;String, Component&gt;</code>) and recreating the tree structure at render time.</p> <p>This model allows the server to send component definitions in any order, as long as all necessary components are present by the time <code>beginRendering</code> is sent.</p> <pre><code>flowchart TD\n    subgraph \"Server Stream (JSONL)\"\n        A(\"&lt;b&gt;surfaceUpdate&lt;/b&gt;&lt;br&gt;components: [root, title, button, button_text]\")\n        B(\"&lt;b&gt;beginRendering&lt;/b&gt;&lt;br&gt;root: 'root'\")\n    end\n\n    subgraph \"Client-Side Buffer (Map)\"\n        C(\"root: {id: 'root', type: Column, children: ['title', 'button']}\")\n        D(\"title: {id: 'title', type: Text, text: 'Welcome'}\")\n        E(\"button: {id: 'button', type: Button, child: 'button_text'}\")\n        E_TEXT(\"button_text: {id: 'button_text', type: Text, text: 'Go'}\")\n    end\n\n    subgraph \"Rendered Widget Tree\"\n        F(Column) --&gt; G(Text: 'Welcome')\n        F --&gt; H(Button)\n        H --&gt; I(Text: 'Go')\n    end\n\n    A -- \"Parsed and stored\" --&gt; C\n    A -- \"Parsed and stored\" --&gt; D\n    A -- \"Parsed and stored\" --&gt; E\n    A -- \"Parsed and stored\" --&gt; E_TEXT\n\n    B -- \"Triggers build from buffer\" --&gt; F</code></pre>"},{"location":"a2ui_protocol/#32-container-children-explicitlist-vs-template","title":"3.2. Container Children: <code>explicitList</code> vs. <code>template</code>","text":"<p>Container components (<code>Row</code>, <code>Column</code>, <code>List</code>) define their children using a <code>children</code> object, which must contain either <code>explicitList</code> or <code>template</code>.</p> <ul> <li><code>explicitList</code>: An array of component <code>id</code> strings. This is used for static, known children.</li> <li><code>template</code>: An object used to render a dynamic list of children from a data-bound list.</li> </ul> <pre><code>// Example: Children property from a2ui_schema.json\n\"children\": {\n  \"description\": \"Defines the children... You MUST define EITHER 'explicitList' OR 'template'\",\n  \"properties\": {\n    \"explicitList\": {\n      \"type\": \"array\",\n      \"items\": { \"type\": \"string\" }\n    },\n    \"template\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"componentId\": { \"type\": \"string\" },\n        \"dataBinding\": { \"type\": \"string\" }\n      },\n      \"required\": [\"componentId\", \"dataBinding\"]\n    }\n  }\n}\n</code></pre>"},{"location":"a2ui_protocol/#33-dynamic-list-rendering-with-template","title":"3.3. Dynamic List Rendering with <code>template</code>","text":"<p>To render dynamic lists, a container uses the <code>template</code> property.</p> <ol> <li><code>dataBinding</code>: A path to a list in the data model (e.g., <code>user.posts</code>).</li> <li><code>componentId</code>: The <code>id</code> of another component in the buffer to use as a template for each item in the list.</li> </ol> <p>The client will iterate over the list at <code>dataBinding</code> and, for each item, render the component specified by <code>componentId</code>. The item's data is made available to the template component for relative data binding.</p>"},{"location":"a2ui_protocol/#section-4-dynamic-data-state-management","title":"Section 4: Dynamic Data &amp; State Management","text":"<p>A2UI enforces a clean separation between the UI's structure (components) and its dynamic data (data model).</p>"},{"location":"a2ui_protocol/#41-the-datamodelupdate-message","title":"4.1. The <code>dataModelUpdate</code> Message","text":"<p>This message is the only way to modify the client's data model.</p> <ul> <li><code>surfaceId</code>: The unique identifier for the UI surface this data model update applies to.</li> <li><code>path</code>: An optional path to a location within the data model (e.g., 'user.name'). If omitted, the update applies to the root of the data model.</li> <li><code>contents</code>: An array of data entries. Each entry must contain a 'key' and exactly one corresponding typed 'value*' property (e.g. <code>valueString</code>, <code>valueNumber</code>, <code>valueBoolean</code>, <code>valueList</code>).</li> </ul>"},{"location":"a2ui_protocol/#example-updating-the-data-model","title":"Example: Updating the data model","text":"<pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"path\": \"user\",\n    \"contents\": [\n      { \"key\": \"name\", \"valueString\": \"Bob\" },\n      { \"key\": \"isVerified\", \"valueBoolean\": true }\n    ]\n  }\n}\n</code></pre>"},{"location":"a2ui_protocol/#42-data-binding-the-boundvalue-object","title":"4.2. Data Binding (The <code>BoundValue</code> Object)","text":"<p>Components connect to the data model through binding. Any property that can be data-bound (like <code>text</code> on a <code>Text</code> component) accepts a <code>BoundValue</code> object. This object defines either a literal value, a data path, or both as a shorthand for initialization.</p> <p>From the catalog schema, a bound <code>text</code> property looks like this:</p> <pre><code>\"text\": {\n  \"properties\": {\n    \"path\": { \"type\": \"string\" },\n    \"literalString\": { \"type\": \"string\" }\n  }\n}\n</code></pre> <p>A component can also bind to numbers (<code>literalNumber</code>), booleans (<code>literalBoolean</code>), or arrays (<code>literalArray</code>). The behavior depends on which properties are provided:</p> <ul> <li>Literal Value Only: If only a <code>literal*</code> value (e.g., <code>literalString</code>) is provided, the value is static and displayed directly.</li> </ul> <pre><code>\"text\": { \"literalString\": \"Hello\" }\n</code></pre> <ul> <li>Path Only: If only <code>path</code> is provided, the value is dynamic. It's resolved from the data model at render time.</li> </ul> <pre><code>\"text\": { \"path\": \"user.name\" }\n</code></pre> <ul> <li> <p>Path and Literal Value (Initialization Shorthand): If both <code>path</code> and a <code>literal*</code> value are provided, it serves as a shorthand for data model initialization. The client MUST:</p> </li> <li> <p>Update the data model at the specified <code>path</code> with the provided <code>literal*</code> value. This is an implicit <code>dataModelUpdate</code>.</p> </li> <li>Bind the component property to that <code>path</code> for rendering and future updates.</li> </ul> <p>This allows the server to set a default value and bind to it in a single step.</p> <pre><code>// This initializes data model at 'user.name' to \"Guest\" and binds to it.\n\"text\": { \"path\": \"user.name\", \"literalString\": \"Guest\" }\n</code></pre> <p>The client's interpreter is responsible for resolving these paths against the data model before rendering. The A2UI protocol supports direct 1:1 binding; it does not include transformers (e.g., formatters, conditionals). Any data transformation must be performed by the server before sending it in a <code>dataModelUpdate</code>.</p>"},{"location":"a2ui_protocol/#section-5-event-handling","title":"Section 5: Event Handling","text":"<p>While the server-to-client UI definition is a one-way stream (e.g., over SSE), user interactions are communicated back to the server using an A2A message.</p>"},{"location":"a2ui_protocol/#51-the-client-event-message","title":"5.1. The Client Event Message","text":"<p>The client sends a single JSON object that acts as a wrapper. It must contain exactly one of the following keys: <code>userAction</code>, <code>clientUiCapabilities</code>, or <code>error</code>.</p>"},{"location":"a2ui_protocol/#52-the-useraction-message","title":"5.2. The <code>userAction</code> Message","text":"<p>This message is sent when the user interacts with a component that has an action defined. It is the primary mechanism for user-driven events.</p> <p>The <code>userAction</code> object has the following structure:</p> <ul> <li><code>name</code> (string, required): The name of the action, taken directly from the <code>action.name</code> property of the component (e.g., \"submit_form\").</li> <li><code>surfaceId</code> (string, required): The <code>id</code> of the surface where the event originated.</li> <li><code>sourceComponentId</code> (string, required): The <code>id</code> of the component that triggered the event (e.g., \"my_button\").</li> <li><code>timestamp</code> (string, required): An ISO 8601 timestamp of when the event occurred (e.g., \"2025-09-19T17:01:00Z\").</li> <li><code>context</code> (object, required): A JSON object containing the key-value pairs from the component's <code>action.context</code>, after resolving all <code>BoundValue</code>s against the data model.</li> </ul> <p>The process for resolving the <code>action.context</code> remains the same: the client iterates over the <code>context</code> array, resolves all literal or data-bound values, and constructs the <code>context</code> object.</p>"},{"location":"a2ui_protocol/#53-the-clientuicapabilities-message","title":"5.3. The <code>clientUiCapabilities</code> Message","text":"<p>This message is sent by the client to inform the server about its capabilities. This is crucial for supporting different component sets, allowing the server to generate UI that is compatible with the client. The message must contain exactly one of the following properties: <code>catalogUri</code> or <code>dynamicCatalog</code>.</p> <ul> <li><code>catalogUri</code>: A URI pointing to a predefined component catalog schema that the client supports.</li> <li><code>dynamicCatalog</code>: An inline JSON object, conforming to the Catalog Schema, that defines the client's supported components. This is useful for development or for clients with highly custom component sets.</li> </ul>"},{"location":"a2ui_protocol/#dynamiccatalog","title":"<code>dynamicCatalog</code>","text":"<p>The <code>dynamicCatalog</code> property allows the client to send an inline JSON object that defines its entire supported component set. This is especially useful for development or for clients with highly custom components. The object must conform to the Catalog Schema, containing <code>components</code>.</p> <ul> <li><code>components</code>: An object where each key is the name of a component (e.g., <code>\"MyCustomCard\"</code>) and the value is a valid JSON object schema defining the properties for that component.</li> </ul> <p>Example of a <code>clientUiCapabilities</code> message with a dynamic catalog:</p> <pre><code>{\n  \"clientUiCapabilities\": {\n    \"dynamicCatalog\": {\n      \"components\": {\n        \"StatusPill\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"text\": { \"$ref\": \"#/definitions/BoundValue\" },\n            \"statusColor\": { \"type\": \"string\" }\n          },\n          \"required\": [\"text\", \"statusColor\"]\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"a2ui_protocol/#54-the-error-message","title":"5.4. The <code>error</code> Message","text":"<p>This message provides a feedback mechanism for the server. It is sent when the client encounters an error, for instance, during UI rendering or data binding. The content of the object is flexible and can contain any relevant error information.</p>"},{"location":"a2ui_protocol/#55-event-flow-example-useraction","title":"5.5. Event Flow Example (<code>userAction</code>)","text":"<ol> <li> <p>Component Definition (from <code>surfaceUpdate</code>):</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"components\": [\n      {\n        \"id\": \"submit_btn_text\",\n        \"component\": {\n          \"Text\": {\n            \"text\": { \"literalString\": \"Submit\" }\n          }\n        }\n      },\n      {\n        \"id\": \"submit_btn\",\n        \"component\": {\n          \"Button\": {\n            \"child\": \"submit_btn_text\",\n            \"action\": {\n              \"name\": \"submit_form\",\n              \"context\": [\n                {\n                  \"key\": \"userInput\",\n                  \"value\": { \"path\": \"form.textField\" }\n                },\n                { \"key\": \"formId\", \"value\": { \"literalString\": \"f-123\" } }\n              ]\n            }\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> </li> <li> <p>Data Model (from <code>dataModelUpdate</code>):</p> <pre><code>{\n  \"dataModelUpdate\": {\n    \"surfaceId\": \"main_content_area\",\n    \"form\": {\n      \"textField\": \"User input text\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>User Action: The user taps the \"submit_btn\" button.</p> </li> <li>Client-Side Resolution: The client resolves the <code>action.context</code>.</li> <li> <p>Client-to-Server Request: The client sends a <code>POST</code> request to <code>https://api.example.com/handle_event</code> with the following JSON body:</p> <pre><code>{\n  \"userAction\": {\n    \"name\": \"submit_form\",\n    \"surfaceId\": \"main_content_area\",\n    \"sourceComponentId\": \"submit_btn\",\n    \"timestamp\": \"2025-09-19T17:05:00Z\",\n    \"context\": {\n      \"userInput\": \"User input text\",\n      \"formId\": \"f-123\"\n    }\n  }\n}\n</code></pre> </li> <li> <p>Server Response: The server processes this event. If the UI needs to change as a result, the server sends new <code>surfaceUpdate</code> or <code>dataModelUpdate</code> messages over the separate SSE stream.</p> </li> </ol>"},{"location":"a2ui_protocol/#section-6-client-side-implementation","title":"Section 6: Client-Side Implementation","text":"<p>A robust client-side interpreter for A2UI should be composed of several key components:</p> <ul> <li>JSONL Parser: A parser capable of reading the stream line by line and decoding each line as a separate JSON object.</li> <li>Message Dispatcher: A mechanism (e.g., a <code>switch</code> statement) to identify the message type (<code>streamHeader</code>, <code>componentUpdate</code>, etc.) and route it to the correct handler.</li> <li>Component Buffer: A <code>Map&lt;String, Component&gt;</code> that stores all component instances by their <code>id</code>. This is populated by <code>componentUpdate</code> messages.</li> <li>Data Model Store: A <code>Map&lt;String, dynamic&gt;</code> (or similar) that holds the application state. This is built and modified by <code>dataModelUpdate</code> messages.</li> <li>Interpreter State: A state machine to track if the client is ready to render (e.g., a <code>_isReadyToRender</code> boolean that is set to <code>true</code> by <code>beginRendering</code>).</li> <li>Widget Registry: A developer-provided map (e.g., <code>Map&lt;String, WidgetBuilder&gt;</code>) that associates component type strings (\"Row\", \"Text\") with functions that build native widgets.</li> <li>Binding Resolver: A utility that can take a <code>BoundValue</code> (e.g., <code>{ \"path\": \"user.name\" }</code>) and resolve it against the Data Model Store.</li> <li>Surface Manager: Logic to create, update, and delete UI surfaces based on <code>surfaceId</code>.</li> <li>Event Handler: A function, exposed to the <code>WidgetRegistry</code>, that constructs and sends the client event message (e.g., <code>userAction</code>) to the configured REST API endpoint.</li> </ul>"},{"location":"a2ui_protocol/#section-7-complete-a2ui-server-to-client-json-schema","title":"Section 7: Complete A2UI Server To Client JSON Schema","text":"<p>This section provides the formal JSON Schema for a single server-to-client message in the A2UI JSONL stream. Each line in the stream must be a valid JSON object that conforms to this schema. It includes the entire base catalog of components, but the components may be swapped out for other components supported by the client. It is optimized to be able to be generated in structured output mode from various LLMs.</p> <pre><code>{\n  \"title\": \"A2UI Message Schema\",\n  \"description\": \"Describes a JSON payload for an A2UI (Agent to UI) message, which is used to dynamically construct and update user interfaces. A message MUST contain exactly ONE of the action properties: 'beginRendering', 'surfaceUpdate', 'dataModelUpdate', or 'deleteSurface'.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"beginRendering\": {\n      \"type\": \"object\",\n      \"description\": \"Signals the client to begin rendering a surface with a root component and specific styles.\",\n      \"properties\": {\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The unique identifier for the UI surface to be rendered.\"\n        },\n        \"root\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the root component to render.\"\n        },\n        \"styles\": {\n          \"type\": \"object\",\n          \"description\": \"Styling information for the UI.\",\n          \"properties\": {\n            \"font\": {\n              \"type\": \"string\",\n              \"description\": \"The primary font for the UI.\"\n            },\n            \"primaryColor\": {\n              \"type\": \"string\",\n              \"description\": \"The primary UI color as a hexadecimal code (e.g., '#00BFFF').\",\n              \"pattern\": \"^#[0-9a-fA-F]{6}$\"\n            }\n          }\n        }\n      },\n      \"required\": [\"root\", \"surfaceId\"]\n    },\n    \"surfaceUpdate\": {\n      \"type\": \"object\",\n      \"description\": \"Updates a surface with a new set of components.\",\n      \"properties\": {\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The unique identifier for the UI surface to be updated. If you are adding a new surface this *must* be a new, unique identified that has never been used for any existing surfaces shown.\"\n        },\n        \"components\": {\n          \"type\": \"array\",\n          \"description\": \"A list containing all UI components for the surface.\",\n          \"minItems\": 1,\n          \"items\": {\n            \"type\": \"object\",\n            \"description\": \"Represents a *single* component in a UI widget tree. This component could be one of many supported types.\",\n            \"properties\": {\n              \"id\": {\n                \"type\": \"string\",\n                \"description\": \"The unique identifier for this component.\"\n              },\n              \"component\": {\n                \"type\": \"object\",\n                \"description\": \"A wrapper object that MUST contain exactly one key, which is the name of the component type (e.g., 'Heading'). The value is an object containing the properties for that specific component.\",\n                \"properties\": {\n                  \"Heading\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"text\": {\n                        \"type\": \"object\",\n                        \"description\": \"The text content for the heading. This can be a literal string or a reference to a value in the data model ('path', e.g. 'doc.title').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"level\": {\n                        \"type\": \"string\",\n                        \"description\": \"The heading level, corresponding to HTML heading tags (e.g., '1' for &lt;h1&gt;, '2' for &lt;h2&gt;).\",\n                        \"enum\": [\"1\", \"2\", \"3\", \"4\", \"5\"]\n                      }\n                    },\n                    \"required\": [\"text\"]\n                  },\n                  \"Text\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"text\": {\n                        \"type\": \"object\",\n                        \"description\": \"The text content to display. This can be a literal string or a reference to a value in the data model ('path', e.g. 'hotel.description').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      }\n                    },\n                    \"required\": [\"text\"]\n                  },\n                  \"Image\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"url\": {\n                        \"type\": \"object\",\n                        \"description\": \"The URL of the image to display. This can be a literal string ('literal') or a reference to a value in the data model ('path', e.g. 'thumbnail.url').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"fit\": {\n                        \"type\": \"string\",\n                        \"description\": \"Specifies how the image should be resized to fit its container. This corresponds to the CSS 'object-fit' property.\",\n                        \"enum\": [\n                          \"contain\",\n                          \"cover\",\n                          \"fill\",\n                          \"none\",\n                          \"scale-down\"\n                        ]\n                      }\n                    },\n                    \"required\": [\"url\"]\n                  },\n                  \"Video\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"url\": {\n                        \"type\": \"object\",\n                        \"description\": \"The URL of the video to display. This can be a literal string or a reference to a value in the data model ('path', e.g. 'video.url').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      }\n                    },\n                    \"required\": [\"url\"]\n                  },\n                  \"AudioPlayer\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"url\": {\n                        \"type\": \"object\",\n                        \"description\": \"The URL of the audio to be played. This can be a literal string ('literal') or a reference to a value in the data model ('path', e.g. 'song.url').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"description\": {\n                        \"type\": \"object\",\n                        \"description\": \"A description of the audio, such as a title or summary. This can be a literal string or a reference to a value in the data model ('path', e.g. 'song.title').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      }\n                    },\n                    \"required\": [\"url\"]\n                  },\n                  \"Row\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"children\": {\n                        \"type\": \"object\",\n                        \"description\": \"Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.\",\n                        \"properties\": {\n                          \"explicitList\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                              \"type\": \"string\"\n                            }\n                          },\n                          \"template\": {\n                            \"type\": \"object\",\n                            \"description\": \"A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the list in the data model.\",\n                            \"properties\": {\n                              \"componentId\": {\n                                \"type\": \"string\"\n                              },\n                              \"dataBinding\": {\n                                \"type\": \"string\"\n                              }\n                            },\n                            \"required\": [\"componentId\", \"dataBinding\"]\n                          }\n                        }\n                      },\n                      \"distribution\": {\n                        \"type\": \"string\",\n                        \"description\": \"Defines the arrangement of children along the main axis (horizontally). This corresponds to the CSS 'justify-content' property.\",\n                        \"enum\": [\n                          \"center\",\n                          \"end\",\n                          \"spaceAround\",\n                          \"spaceBetween\",\n                          \"spaceEvenly\",\n                          \"start\"\n                        ]\n                      },\n                      \"alignment\": {\n                        \"type\": \"string\",\n                        \"description\": \"Defines the alignment of children along the cross axis (vertically). This corresponds to the CSS 'align-items' property.\",\n                        \"enum\": [\"start\", \"center\", \"end\", \"stretch\"]\n                      }\n                    },\n                    \"required\": [\"children\"]\n                  },\n                  \"Column\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"children\": {\n                        \"type\": \"object\",\n                        \"description\": \"Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.\",\n                        \"properties\": {\n                          \"explicitList\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                              \"type\": \"string\"\n                            }\n                          },\n                          \"template\": {\n                            \"type\": \"object\",\n                            \"description\": \"A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the list in the data model.\",\n                            \"properties\": {\n                              \"componentId\": {\n                                \"type\": \"string\"\n                              },\n                              \"dataBinding\": {\n                                \"type\": \"string\"\n                              }\n                            },\n                            \"required\": [\"componentId\", \"dataBinding\"]\n                          }\n                        }\n                      },\n                      \"distribution\": {\n                        \"type\": \"string\",\n                        \"description\": \"Defines the arrangement of children along the main axis (vertically). This corresponds to the CSS 'justify-content' property.\",\n                        \"enum\": [\n                          \"start\",\n                          \"center\",\n                          \"end\",\n                          \"spaceBetween\",\n                          \"spaceAround\",\n                          \"spaceEvenly\"\n                        ]\n                      },\n                      \"alignment\": {\n                        \"type\": \"string\",\n                        \"description\": \"Defines the alignment of children along the cross axis (horizontally). This corresponds to the CSS 'align-items' property.\",\n                        \"enum\": [\"center\", \"end\", \"start\", \"stretch\"]\n                      }\n                    },\n                    \"required\": [\"children\"]\n                  },\n                  \"List\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"children\": {\n                        \"type\": \"object\",\n                        \"description\": \"Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.\",\n                        \"properties\": {\n                          \"explicitList\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                              \"type\": \"string\"\n                            }\n                          },\n                          \"template\": {\n                            \"type\": \"object\",\n                            \"description\": \"A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the list in the data model.\",\n                            \"properties\": {\n                              \"componentId\": {\n                                \"type\": \"string\"\n                              },\n                              \"dataBinding\": {\n                                \"type\": \"string\"\n                              }\n                            },\n                            \"required\": [\"componentId\", \"dataBinding\"]\n                          }\n                        }\n                      },\n                      \"direction\": {\n                        \"type\": \"string\",\n                        \"description\": \"The direction in which the list items are laid out.\",\n                        \"enum\": [\"vertical\", \"horizontal\"]\n                      },\n                      \"alignment\": {\n                        \"type\": \"string\",\n                        \"description\": \"Defines the alignment of children along the cross axis.\",\n                        \"enum\": [\"start\", \"center\", \"end\", \"stretch\"]\n                      }\n                    },\n                    \"required\": [\"children\"]\n                  },\n                  \"Card\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"child\": {\n                        \"type\": \"string\",\n                        \"description\": \"The ID of the component to be rendered inside the card.\"\n                      }\n                    },\n                    \"required\": [\"child\"]\n                  },\n                  \"Tabs\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"tabItems\": {\n                        \"type\": \"array\",\n                        \"description\": \"An array of objects, where each object defines a tab with a title and a child component.\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"title\": {\n                              \"type\": \"object\",\n                              \"description\": \"The tab title. Defines the value as either a literal value or a path to data model value (e.g. 'options.title').\",\n                              \"properties\": {\n                                \"literalString\": {\n                                  \"type\": \"string\"\n                                },\n                                \"path\": {\n                                  \"type\": \"string\"\n                                }\n                              }\n                            },\n                            \"child\": {\n                              \"type\": \"string\"\n                            }\n                          },\n                          \"required\": [\"title\", \"child\"]\n                        }\n                      }\n                    },\n                    \"required\": [\"tabItems\"]\n                  },\n                  \"Divider\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"axis\": {\n                        \"type\": \"string\",\n                        \"description\": \"The orientation of the divider.\",\n                        \"enum\": [\"horizontal\", \"vertical\"]\n                      }\n                    }\n                  },\n                  \"Modal\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"entryPointChild\": {\n                        \"type\": \"string\",\n                        \"description\": \"The ID of the component that opens the modal when interacted with (e.g., a button).\"\n                      },\n                      \"contentChild\": {\n                        \"type\": \"string\",\n                        \"description\": \"The ID of the component to be displayed inside the modal.\"\n                      }\n                    },\n                    \"required\": [\"entryPointChild\", \"contentChild\"]\n                  },\n                  \"Button\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"child\": {\n                        \"type\": \"string\",\n                        \"description\": \"The ID of the component to display in the button, typically a Text component.\"\n                      },\n                      \"action\": {\n                        \"type\": \"object\",\n                        \"description\": \"The client-side action to be dispatched when the button is clicked. It includes the action's name and an optional context payload.\",\n                        \"properties\": {\n                          \"name\": {\n                            \"type\": \"string\"\n                          },\n                          \"context\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                              \"type\": \"object\",\n                              \"properties\": {\n                                \"key\": {\n                                  \"type\": \"string\"\n                                },\n                                \"value\": {\n                                  \"type\": \"object\",\n                                  \"description\": \"Defines the value to be included in the context as either a literal value or a path to a data model value (e.g. 'user.name').\",\n                                  \"properties\": {\n                                    \"path\": {\n                                      \"type\": \"string\"\n                                    },\n                                    \"literalString\": {\n                                      \"type\": \"string\"\n                                    },\n                                    \"literalNumber\": {\n                                      \"type\": \"number\"\n                                    },\n                                    \"literalBoolean\": {\n                                      \"type\": \"boolean\"\n                                    }\n                                  }\n                                }\n                              },\n                              \"required\": [\"key\", \"value\"]\n                            }\n                          }\n                        },\n                        \"required\": [\"name\"]\n                      }\n                    },\n                    \"required\": [\"child\", \"action\"]\n                  },\n                  \"CheckBox\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"label\": {\n                        \"type\": \"object\",\n                        \"description\": \"The text to display next to the checkbox. Defines the value as either a literal value or a path to data model ('path', e.g. 'option.label').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"value\": {\n                        \"type\": \"object\",\n                        \"description\": \"The current state of the checkbox (true for checked, false for unchecked). This can be a literal boolean ('literalBoolean') or a reference to a value in the data model ('path', e.g. 'filter.open').\",\n                        \"properties\": {\n                          \"literalBoolean\": {\n                            \"type\": \"boolean\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      }\n                    },\n                    \"required\": [\"label\", \"value\"]\n                  },\n                  \"TextField\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"label\": {\n                        \"type\": \"object\",\n                        \"description\": \"The text label for the input field. This can be a literal string or a reference to a value in the data model ('path, e.g. 'user.name').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"text\": {\n                        \"type\": \"object\",\n                        \"description\": \"The value of the text field. This can be a literal string or a reference to a value in the data model ('path', e.g. 'user.name').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"textFieldType\": {\n                        \"type\": \"string\",\n                        \"description\": \"The type of input field to display.\",\n                        \"enum\": [\n                          \"date\",\n                          \"longText\",\n                          \"number\",\n                          \"shortText\",\n                          \"obscured\"\n                        ]\n                      },\n                      \"validationRegexp\": {\n                        \"type\": \"string\",\n                        \"description\": \"A regular expression used for client-side validation of the input.\"\n                      }\n                    },\n                    \"required\": [\"label\"]\n                  },\n                  \"DateTimeInput\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"value\": {\n                        \"type\": \"object\",\n                        \"description\": \"The selected date and/or time value. This can be a literal string ('literalString') or a reference to a value in the data model ('path', e.g. 'user.dob').\",\n                        \"properties\": {\n                          \"literalString\": {\n                            \"type\": \"string\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"enableDate\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"If true, allows the user to select a date.\"\n                      },\n                      \"enableTime\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"If true, allows the user to select a time.\"\n                      },\n                      \"outputFormat\": {\n                        \"type\": \"string\",\n                        \"description\": \"The desired format for the output string after a date or time is selected.\"\n                      }\n                    },\n                    \"required\": [\"value\"]\n                  },\n                  \"MultipleChoice\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"selections\": {\n                        \"type\": \"object\",\n                        \"description\": \"The currently selected values for the component. This can be a literal array of strings or a path to an array in the data model('path', e.g. 'hotel.options').\",\n                        \"properties\": {\n                          \"literalArray\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                              \"type\": \"string\"\n                            }\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"options\": {\n                        \"type\": \"array\",\n                        \"description\": \"An array of available options for the user to choose from.\",\n                        \"items\": {\n                          \"type\": \"object\",\n                          \"properties\": {\n                            \"label\": {\n                              \"type\": \"object\",\n                              \"description\": \"The text to display for this option. This can be a literal string or a reference to a value in the data model (e.g. 'option.label').\",\n                              \"properties\": {\n                                \"literalString\": {\n                                  \"type\": \"string\"\n                                },\n                                \"path\": {\n                                  \"type\": \"string\"\n                                }\n                              }\n                            },\n                            \"value\": {\n                              \"type\": \"string\",\n                              \"description\": \"The value to be associated with this option when selected.\"\n                            }\n                          },\n                          \"required\": [\"label\", \"value\"]\n                        }\n                      },\n                      \"maxAllowedSelections\": {\n                        \"type\": \"integer\",\n                        \"description\": \"The maximum number of options that the user is allowed to select.\"\n                      }\n                    },\n                    \"required\": [\"selections\", \"options\"]\n                  },\n                  \"Slider\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                      \"value\": {\n                        \"type\": \"object\",\n                        \"description\": \"The current value of the slider. This can be a literal number ('literalNumber') or a reference to a value in the data model ('path', e.g. 'restaurant.cost').\",\n                        \"properties\": {\n                          \"literalNumber\": {\n                            \"type\": \"number\"\n                          },\n                          \"path\": {\n                            \"type\": \"string\"\n                          }\n                        }\n                      },\n                      \"minValue\": {\n                        \"type\": \"number\",\n                        \"description\": \"The minimum value of the slider.\"\n                      },\n                      \"maxValue\": {\n                        \"type\": \"number\",\n                        \"description\": \"The maximum value of the slider.\"\n                      }\n                    },\n                    \"required\": [\"value\"]\n                  }\n                }\n              }\n            },\n            \"required\": [\"id\", \"component\"]\n          }\n        }\n      },\n      \"required\": [\"surfaceId\", \"components\"]\n    },\n    \"dataModelUpdate\": {\n      \"type\": \"object\",\n      \"description\": \"Updates the data model for a surface.\",\n      \"properties\": {\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The unique identifier for the UI surface this data model update applies to.\"\n        },\n        \"path\": {\n          \"type\": \"string\",\n          \"description\": \"An optional path to a location within the data model (e.g., 'user.name'). If omitted, the entire data model will be replaced.\"\n        },\n        \"contents\": {\n          \"type\": \"array\",\n          \"description\": \"An array of data entries. Each entry must contain a 'key' and exactly one corresponding typed 'value*' property.\",\n          \"items\": {\n            \"type\": \"object\",\n            \"description\": \"A single data entry. Exactly one 'value*' property should be provided alongside the key.\",\n            \"properties\": {\n              \"key\": {\n                \"type\": \"string\",\n                \"description\": \"The key for this data entry.\"\n              },\n              \"valueString\": {\n                \"type\": \"string\"\n              },\n              \"valueNumber\": {\n                \"type\": \"number\"\n              },\n              \"valueBoolean\": {\n                \"type\": \"boolean\"\n              },\n              \"valueList\": {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"valueString\": {\n                      \"type\": \"string\"\n                    },\n                    \"valueNumber\": {\n                      \"type\": \"number\"\n                    },\n                    \"valueBoolean\": {\n                      \"type\": \"boolean\"\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      \"required\": [\"contents\", \"surfaceId\"]\n    },\n    \"deleteSurface\": {\n      \"type\": \"object\",\n      \"description\": \"Signals the client to delete the surface identified by 'surfaceId'.\",\n      \"properties\": {\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The unique identifier for the UI surface to be deleted.\"\n        }\n      },\n      \"required\": [\"surfaceId\"]\n    }\n  }\n}\n</code></pre>"},{"location":"a2ui_protocol/#section-8-client-to-server-json-schema","title":"Section 8: Client-to-Server JSON Schema","text":"<p>This section provides the formal JSON Schema for the client-to-server event message. The client sends a single JSON object that must conform to this schema. This doesn\u2019t have to be generated by an LLM, so it can include JSON schema elements that are incompatible with structured output.</p> <pre><code>{\n  \"title\": \"A2UI Client-to-Server Event Schema\",\n  \"description\": \"Describes a JSON payload for a client-to-server event message.\",\n  \"type\": \"object\",\n  \"minProperties\": 1,\n  \"maxProperties\": 1,\n  \"properties\": {\n    \"userAction\": {\n      \"type\": \"object\",\n      \"description\": \"Reports a user-initiated action from a component.\",\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"description\": \"The name of the action, taken from the component's action.name property.\"\n        },\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The id of the surface where the event originated.\"\n        },\n        \"sourceComponentId\": {\n          \"type\": \"string\",\n          \"description\": \"The id of the component that triggered the event.\"\n        },\n        \"timestamp\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\",\n          \"description\": \"An ISO 8601 timestamp of when the event occurred.\"\n        },\n        \"context\": {\n          \"type\": \"object\",\n          \"description\": \"A JSON object containing the key-value pairs from the component's action.context, after resolving all data bindings.\",\n          \"additionalProperties\": true\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"surfaceId\",\n        \"sourceComponentId\",\n        \"timestamp\",\n        \"context\"\n      ]\n    },\n    \"clientUiCapabilities\": {\n      \"type\": \"object\",\n      \"description\": \"Informs the server about the client's capabilities, such as the component catalog it supports. Exactly ONE of the properties in this object must be set.\",\n      \"properties\": {\n        \"catalogUri\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"description\": \"A URI pointing to a predefined component catalog schema that the client supports.\"\n        },\n        \"dynamicCatalog\": {\n          \"type\": \"object\",\n          \"description\": \"An inline JSON object that defines the client's supported components.\",\n          \"properties\": {\n            \"components\": {\n              \"type\": \"object\",\n              \"description\": \"A map where each key is a component name and the value is a JSON Schema defining an object containing its properties.\",\n              \"additionalProperties\": {\n                \"$ref\": \"https://json-schema.org/draft/2020-12/schema\"\n              }\n            }\n          },\n          \"required\": [\"components\"]\n        }\n      },\n      \"oneOf\": [\n        { \"required\": [\"catalogUri\"] },\n        { \"required\": [\"dynamicCatalog\"] }\n      ]\n    },\n    \"error\": {\n      \"type\": \"object\",\n      \"description\": \"Reports a client-side error. The content is flexible.\",\n      \"additionalProperties\": true\n    }\n  },\n  \"oneOf\": [\n    { \"required\": [\"userAction\"] },\n    { \"required\": [\"clientUiCapabilities\"] },\n    { \"required\": [\"error\"] }\n  ]\n}\n</code></pre>"},{"location":"proposals/v0_8/","title":"Proposal: A2UI v0.8","text":""},{"location":"proposals/v0_8/#aim","title":"Aim","text":"<p>Propose updates to the A2UI protocol so that it fully supports the functionality of the Flutter Gen UI SDK and we can migrate our SDK to be built on top of A2UI.</p> <p>The main new features are:</p> <ul> <li>Separation of the specific component types into a Catalog object</li> <li>Additional Catalog negotiation features to support custom catalogs.</li> <li>Addition of the concept of a \"surface\" which allows the agent to target updates towards specific regions of the UI.</li> </ul>"},{"location":"proposals/v0_8/#requirements","title":"Requirements","text":"<ul> <li>Support custom component catalogs: Clients and servers should be able to use A2UI with a custom component catalog that is known to both of them and is identified by a name.</li> <li>Support dynamically negotiated components: Clients can dynamically send their local custom component library to the server to use, if the server chooses to support this. This is especially useful for local development workflows, and integrations where there is a high level of trust between agent and client.</li> <li>Provide a strict schema for the LLM: The LLM should see a A2UI schema which provides the same degree of strictness as A2UI v0.7, i.e. the LLM should see a schema which specifies all the possible parameters of every widget in the catalog.</li> <li>Standardized component catalog format: We need to standardize the way component catalogs are expressed so that agent logic can easily generate LLM format schemas from them.</li> <li>Multiple surfaces: The ability for the LLM to choose to render into one or more discrete \u201csurfaces\u201d</li> </ul>"},{"location":"proposals/v0_8/#overview","title":"Overview","text":"<p>The overall direction of this proposal is to extend and modularize the formal A2UI protocol schema to make it more flexible and extensible. By separating the core protocol\u2014the fundamental message types and structures\u2014from the specific UI components and styling rules, we can support a wider range of use cases and client capabilities. This layered approach allows for greater customization while maintaining a consistent foundation for communication between servers and clients.</p> <p>The rationale for this is:</p> <ul> <li>Make the wire format agnostic to the catalog so that developers can use custom catalogs. This is the core premise of go/genui-sdk-proposal from the Flutter team, so we need this to be able to adopt A2UI in our SDK.</li> <li>Allows LLMs to author UIs in a different format to the wire format, because the requirements of the wire format (simple for humans to understand, standard across all agents) are slightly different from the LLM format (easy to for LLM to understand, can be tailored to each agent or model).</li> </ul>"},{"location":"proposals/v0_8/#interaction","title":"Interaction","text":"<ol> <li>(optional) Client fetches the server\u2019s agent card to check server capabilities. This will contain the A2A-UI AgentExtension within AgentCapabilities, which will declare what schemas it supports. If the client doesn't do this and requests an unavailable catalog, then the ClientCapabilities request may fail.</li> <li>(optional) If using custom components, the client makes a ClientCapabilities message to the server to specify which catalog to use. If this message is not sent, the agent will use the standard catalog for the particular A2UI protocol version.</li> <li>Client sends some prompt</li> <li>Agent responds with a combination of ComponentUpdate, DataModelUpdate, SurfaceUpdate and DeleteSurface messages.</li> <li>The client will send clientEvent messages with a userAction item when any UI interactions occur.</li> </ol>"},{"location":"proposals/v0_8/#new-concepts","title":"New Concepts","text":""},{"location":"proposals/v0_8/#surfaces","title":"Surfaces","text":"<p>A Surface is a contiguous portion of screen real estate into which an A2UI UI can be rendered. The protocol introduces the concept of a <code>surfaceId</code> to uniquely identify and manage these areas. This allows a single A2UI stream to control multiple, independent UI regions simultaneously. Each surface has a separate root component and a separate hierarchy of components. Each surface has a separate data model, to avoid collision of keys when working with a large number of surfaces.</p> <p>For example, in a chat application, each AI-generated response could be rendered into a separate surface within the conversation history. A separate, persistent surface could be used for a side panel that displays related information.</p> <p>The <code>surfaceId</code> is used in <code>SurfaceUpdate</code> messages to direct component changes to the correct area, and the <code>DeleteSurface</code> message allows for explicitly removing a surface and its contents from the UI.</p>"},{"location":"proposals/v0_8/#updates-to-schemas-and-formats","title":"Updates to schemas and formats","text":""},{"location":"proposals/v0_8/#server-to-client-protocol-schema-updated","title":"Server-to-Client Protocol Schema (updated)","text":"<p>A standard protocol that allows agents to send UI to surfaces.</p> <p>This is similar to v0.7, but the proposal is to:</p> <ul> <li>Make it generic to the component catalog, to allow for custom components.</li> <li>Add a Data Binding Shorthand to allow initializing the data model and binding to it in a single step.</li> </ul>"},{"location":"proposals/v0_8/#client-to-server-event-schema-updated","title":"Client-to-Server Event Schema (updated)","text":"<p>The protocol to allow clients to send messages to agents. This includes user-initiated actions, capability declarations, and error reports.</p>"},{"location":"proposals/v0_8/#catalog-definition-schema-new","title":"Catalog Definition Schema (new)","text":"<p>A schema used to represent a catalog of components that are available. This is used to represent the standard catalog and custom catalogs. This is to allow us to split out the specific catalog definition from the protocol schema.</p>"},{"location":"proposals/v0_8/#llm-schema","title":"LLM Schema","text":"<p>The schema that is actually passed to the LLM by the agent, which is specific to the catalog being used. When you combine the generic Client Protocol Schema and the Standard Catalog Definition, you should be able to produce an LLM schema exactly the same as the v0.7 protocol.</p>"},{"location":"proposals/v0_8/#agentextension-format","title":"AgentExtension format","text":"<p>We define how the \u2018params\u2019 of the AgentExtension declaration in the Agent Card will be used to declare the capabilities.</p>"},{"location":"proposals/v0_8/#updated-data-objects","title":"Updated data objects","text":""},{"location":"proposals/v0_8/#standard-catalog-definition-new","title":"Standard Catalog Definition (new)","text":"<p>An object which represents the standard A2UI catalog and its styling parameters, conforming to the Catalog Schema. This is the standard catalog of widgets that we agreed on in v0.7 e.g. Text, Heading, Row etc. This remains part of A2UI, as a well-known set of components that agents and clients can opt into to achieve the widest possible compatibility.</p>"},{"location":"proposals/v0_8/#changes-to-the-standard-catalog","title":"Changes to the standard catalog","text":"<p>We will update the standard catalog in the following ways:</p> <ul> <li>Image <code>fit</code> Property: A new <code>fit</code> property for the <code>Image</code> component to control how the image is resized.</li> <li>Markdown in <code>Text</code>: The <code>Text</code> component now officially supports markdown.</li> </ul>"},{"location":"proposals/v0_8/#proposed-components","title":"Proposed components","text":""},{"location":"proposals/v0_8/#custom-schema-adapter","title":"Custom Schema Adapter","text":"<p>The schema adapter is an agent-side utility that can accept a custom widget catalog and convert it to a schema which allows the LLM to generate <code>surfaceUpdate</code> messages for a particular catalog reliably.</p> <p>The most simple adapter, which will work for Gemini and other common LLMs, will simply take the \u201ccomponents\u201d from a \u201cCatalog description object\u201d and paste it into <code>surfaceUpdate.components.componentProperties</code> and takes the \u201cstyles\u201d and pastes them into <code>beginRendering.styles</code>. This creates a new schema which includes the detailed widget catalog, and can be passed to the LLM. This schema should be almost identical in structure to a v0.7 A2UI schema. This schema is a strict subset of the more generic v0.8 \u201cServer-to-Client Protocol Schema\u201d and thus messages generated this way do formally conform to the protocol spec.</p>"},{"location":"proposals/v0_8/#detailed-design","title":"Detailed design","text":""},{"location":"proposals/v0_8/#catalog-description-schema","title":"Catalog description schema","text":"<p>This schema is used to define Catalogs of available components, including the available properties of each component. The schema for this is:</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"title\": \"A2UI Catalog\",\n  \"description\": \"A schema that defines a catalog of A2UI components and styles.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"components\": {\n      \"title\": \"A2UI Components\",\n      \"description\": \"A schema that defines a catalog of A2UI components. Each key is a component name, and each value is the JSON schema for that component's properties.\",\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"https://json-schema.org/draft/2020-12/schema\"\n      }\n    },\n    \"styles\": {\n      \"title\": \"A2UI Styles\",\n      \"description\": \"A schema that defines a catalog of A2UI styles. Each key is a style name, and each value is the JSON schema for that style's properties.\",\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"$ref\": \"https://json-schema.org/draft/2020-12/schema\"\n      }\n    }\n  },\n  \"required\": [\"components\", \"styles\"]\n}\n</code></pre>"},{"location":"proposals/v0_8/#server-to-client-protocol-schema","title":"Server-to-Client Protocol Schema","text":"<p>This is based on the four message types defined in v0.7 but makes the following changes:</p> <ul> <li>Formally combines the messages into a combined object. This shows how they can be included in an A2A message.</li> <li>Remove the <code>streamHeader</code> message, because the version of the protocol is activated by the client using the <code>X-A2A-Extensions</code> HTTP header instead, and the version of the catalog is selected using the new <code>clientCapabilities</code> upwards message.</li> <li>Adds the concept of a <code>surfaceId</code> to the top level of the message, and a new <code>deleteSurface</code> message. This allows the protocol to manage multiple independent UI surfaces (e.g., a main view and a side panel) over a single connection. The <code>surfaceId</code> directs updates to the correct UI area, and <code>deleteSurface</code> allows for explicitly closing or dismissing a surface.</li> <li>Replaces the detailed <code>componentProperties</code> in <code>componentUpdate</code> with a generic object. The available components and their properties are no longer defined in the protocol itself but in a separate <code>Catalog</code> definition.</li> <li>Moves styling definitions out of the core protocol and into the <code>Catalog</code>. The <code>styles</code> object in the <code>beginRendering</code> message is now a generic object, allowing the server to send any key-value pairs that are defined in the active catalog's <code>styles</code> section. This makes styling extensible, just like components.</li> </ul> <pre><code>{\n  \"title\": \"A2UI Protocol message\",\n  \"description\": \"A message from the server to the client, which can be one of several types.\",\n  \"properties\": {\n    \"surfaceId\": {\n      \"type\": \"string\",\n      \"description\": \"An ID for the surface that the UI changes should be applied to. If this surface doesn't exist, it will be created. If this is not specified, the default surface will be used.\"\n    },\n    \"beginRendering\": {\n      \"title\": \"BeginRendering Message\",\n      \"description\": \"A schema for a BeginRendering message in the A2A streaming UI protocol. This message signals that the UI can now be rendered and provides initial root component and styling information.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"root\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the root component from which rendering should begin. This is a reference to a component instance by its unique ID. This property is REQUIRED.\"\n        },\n        \"styles\": {\n          \"type\": \"object\",\n          \"description\": \"An object containing styling information for the UI.\",\n          \"additionalProperties\": true\n        }\n      },\n      \"required\": [\"root\", \"type\"]\n    },\n    \"surfaceUpdate\": {\n      \"title\": \"SurfaceUpdate Message\",\n      \"description\": \"A schema for a SurfaceUpdate message in the A2A streaming UI protocol.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"components\": {\n          \"type\": \"array\",\n          \"description\": \"A flat list of all component instances available for rendering. Components reference each other by ID. This property is REQUIRED.\",\n          \"items\": {\n            \"description\": \"A specific instance of a ComponentType with its own unique ID and properties.\",\n            \"type\": \"object\",\n            \"properties\": {\n              \"id\": {\n                \"type\": \"string\",\n                \"description\": \"A unique identifier for this component instance. This property is REQUIRED.\"\n              },\n              \"componentProperties\": {\n                \"type\": \"object\",\n                \"description\": \"Defines the properties for the component type.\",\n                \"additionalProperties\": true\n              }\n            },\n            \"required\": [\"id\", \"componentProperties\"]\n          }\n        }\n      },\n      \"required\": [\"components\", \"type\"]\n    },\n    \"dataModelUpdate\": {\n      \"title\": \"Data model update\",\n      \"description\": \"Sets or replaces the data model at a specified path with new content.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"path\": {\n          \"type\": \"string\",\n          \"description\": \"An optional path to a location within the data model where the content should be inserted or replaced. The path is represented as a dot-separated string and can include array indexing (e.g., 'user.addresses[0].street'). If this field is omitted, the entire data model will be replaced with the provided 'contents'.\"\n        },\n        \"contents\": {\n          \"description\": \"The JSON content to be placed at the specified path. This property is REQUIRED. This can be any valid JSON value (object, array, string, number, boolean, or null). The content at the target path will be completely replaced by this new value.\"\n        }\n      },\n      \"required\": [\"contents\", \"type\"]\n    },\n    \"deleteSurface\": {\n      \"title\": \"DeleteSurface Message\",\n      \"description\": \"A schema for a DeleteSurface message in the A2A streaming UI protocol. This message signals that a surface should be removed from the UI.\",\n      \"type\": \"object\",\n      \"properties\": {},\n      \"required\": []\n    }\n  }\n}\n</code></pre>"},{"location":"proposals/v0_8/#client-to-server-event-schema","title":"Client-to-Server Event Schema","text":"<p>The client sends messages to the server to report user actions, declare capabilities, or send error information. The schema defines three main message types:</p> <ul> <li><code>userAction</code>: Sent when the user interacts with a component that has an action defined. It includes the action name, the <code>surfaceId</code> of the surface it originated from, and any resolved context data.</li> <li><code>clientCapabilities</code>: Sent by the client to inform the server about its capabilities, such as the component catalog it supports. The client can either reference a known catalog by URI or provide a dynamic catalog definition directly.</li> <li><code>error</code>: Sent when the client encounters an error, for instance, during UI rendering or data binding. This provides a feedback mechanism for the server.</li> </ul> <pre><code>{\n  \"title\": \"A2UI Client Event Message\",\n  \"description\": \"A message sent from the client to the server. Exactly ONE of the properties in this object must be set.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"userAction\": {\n      \"title\": \"User Action\",\n      \"description\": \"Represents a user-initiated action, sent from the client to the server.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"actionName\": {\n          \"type\": \"string\",\n          \"description\": \"The name of the action, taken from the component's `action.action` property.\"\n        },\n        \"surfaceId\": {\n          \"type\": \"string\",\n          \"description\": \"The `id` of the surface that the event originated from.\"\n        },\n        \"sourceComponentId\": {\n          \"type\": \"string\",\n          \"description\": \"The `id` of the component that triggered the event.\"\n        },\n        \"timestamp\": {\n          \"type\": \"string\",\n          \"format\": \"date-time\",\n          \"description\": \"An ISO 8601 timestamp of when the event occurred.\"\n        },\n        \"context\": {\n          \"type\": \"object\",\n          \"description\": \"A JSON object containing the key-value pairs from the component's `action.context`, after resolving all data bindings.\",\n          \"additionalProperties\": true\n        }\n      },\n      \"required\": [\"actionName\", \"sourceComponentId\", \"timestamp\", \"context\"]\n    },\n    \"clientUiCapabilities\": {\n      \"title\": \"Client Capabilities\",\n      \"description\": \"A message from the client describing its capabilities, such as the component catalog it supports. Exactly ONE of the properties in this object must be set.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"catalogUri\": {\n          \"type\": \"string\",\n          \"description\": \"A URI pointing to a predefined component catalog schema.\"\n        },\n        \"dynamicCatalog\": {\n          \"$ref\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/catalog.json\"\n        }\n      },\n      \"oneOf\": [\n        {\n          \"required\": [\"catalogUri\"]\n        },\n        {\n          \"required\": [\"dynamicCatalog\"]\n        }\n      ]\n    },\n    \"error\": {\n      \"title\": \"Client Error\",\n      \"description\": \"A message from the client indicating an error occurred, for example, during UI rendering.\",\n      \"type\": \"object\",\n      \"additionalProperties\": true\n    }\n  }\n}\n</code></pre>"},{"location":"proposals/v0_8/#data-binding-and-initialization-shorthand","title":"Data Binding and Initialization Shorthand","text":"<p>To simplify the generation of UIs, especially for LLMs, we propose a shorthand for data binding that also allows for initializing the data model.</p> <p>Currently, to display a dynamic value that has a default, the server must send two separate messages:</p> <ol> <li>A <code>dataModelUpdate</code> message to set the initial value in the data model.</li> <li>An <code>surfaceUpdate</code> message with a component that has a property bound to that data model path.</li> </ol> <p>The proposed shorthand combines these two steps. When a component property that accepts a <code>BoundValue</code> (e.g., <code>text</code>, <code>value</code>) is defined with both a <code>path</code> and a <code>literal*</code> value (e.g., <code>literalString</code>), it should be interpreted as follows:</p> <ol> <li>The client's data model is updated at the specified <code>path</code> with the provided <code>literal*</code> value. This is equivalent to the client implicitly receiving a <code>dataModelUpdate</code> for that path.</li> <li>The component property is then bound to that <code>path</code> for future updates.</li> </ol> <p>Example:</p> <p>Instead of sending two messages:</p> <pre><code>{\"dataModelUpdate\": {\"path\": \"form.name\", \"contents\": \"John Doe\"}}\n{\"surfaceUpdate\": {\"components\": [{\"id\": \"name_field\", \"componentProperties\": {\"TextField\": {\"text\": {\"path\": \"form.name\"}}}}]}}\n</code></pre> <p>The server can send a single message:</p> <pre><code>{\n  \"surfaceUpdate\": {\n    \"components\": [\n      {\n        \"id\": \"name_field\",\n        \"componentProperties\": {\n          \"TextField\": {\n            \"text\": { \"path\": \"form.name\", \"literalString\": \"John Doe\" }\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>This reduces verbosity and simplifies the logic for the server-side generation, making the protocol more \"LLM-friendly\". The client implementation must ensure that this implicit data model update happens before the component is rendered. This change does not alter the schema of the <code>BoundValue</code> object, but rather clarifies the client's expected behavior when both properties are present.</p>"},{"location":"proposals/v0_8/#image-fit-property","title":"Image <code>fit</code> Property","text":"<p>To provide more control over how images are displayed, the <code>Image</code> component will be updated to include a <code>fit</code> property. This property is a string enum that determines how the image should be resized to fit its container. The possible values are derived from the concepts of <code>BoxFit</code> in Flutter and <code>object-fit</code> in CSS.</p> <p>The supported values are:</p> <ul> <li><code>fill</code>: (Default) The image is resized to fill the container, without preserving the aspect ratio.</li> <li><code>cover</code>: The image preserves its aspect ratio and fills the container, cropping any overflowing content.</li> <li><code>contain</code>: The image preserves its aspect ratio and is scaled to fit inside the container, which may leave empty space.</li> <li><code>none</code>: The image is not resized at all.</li> <li><code>scale-down</code>: The image is scaled down to the smaller of <code>none</code> or <code>contain</code>.</li> </ul> <p>This addition will be reflected in the standard catalog and the LLM schema.</p>"},{"location":"proposals/v0_8/#markdown-support-in-text-component","title":"Markdown Support in <code>Text</code> Component","text":"<p>To enhance the richness of the content that can be displayed, the <code>Text</code> component will now officially support markdown. The <code>text</code> property of the <code>Text</code> component will be updated to clarify that its content will be rendered as markdown, allowing for formatting such as bold, italics, lists, and links.</p>"},{"location":"proposals/v0_8/#extensions","title":"Extensions","text":""},{"location":"proposals/v0_8/#formalized-agentcard-agentextension-example","title":"Formalized AgentCard AgentExtension example","text":"<p>AgentCards can specify a list of AgentExtensions within their AgentCapabilities. We could define how an AgentExtension can use parameters to declare what schemas it supports, so that a client can understand whether it can connect to it and what schemas it can choose from.</p> <p>The AgentExtension declaration includes params:</p> <ul> <li><code>supportedSchemas</code>: defines which UI schema versions are supported by the agent.</li> <li><code>acceptsDynamicSchemas</code>: defines whether the agent can accept dynamic schemas propagated from the client, e.g. details of additional custom components that can be used.</li> </ul> <pre><code>{\n  \"name\": \"Restaurant finder\",\n  \"capabilities\": {\n    \"extensions\": [\n      {\n        \"uri\": \"https://a2ui.org/ext/a2a-ui/v0.1\",\n        \"description\": \"Ability to render A2UI\",\n        \"required\": false,\n        \"params\": {\n          \"supportedSchemas\": [\n            \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/standard_catalog.json\"\n          ],\n          \"acceptsDynamicSchemas\": true\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"proposals/v0_8/#catalog-building-blocks","title":"Catalog Building blocks","text":"<p>The standard catalog contains some subschemas which would benefit from being reused by custom components, to ensure consistency of practices in defining component hierarchies, binding to the data model, and defining actions.</p> <p>We could separate out these subschemas into individual files with uris that can be referenced by custom schemas, to ensure consistency of structure. This consistency would make it easier to implement renderers that support custom components, or generic validators which can parse LLM output and check that the references between components are valid etc without attempting actual rendering.</p>"},{"location":"proposals/v0_8/#stringreferencejson","title":"stringReference.json","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/stringReference.json\",\n  \"title\": \"String Reference\",\n  \"description\": \"A reference that can either be a data model path or a literal string.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"path\": {\n      \"type\": \"string\",\n      \"description\": \"A data binding reference to a location in the data model (e.g., '/user/name').\"\n    },\n    \"literalString\": {\n      \"type\": \"string\",\n      \"description\": \"A fixed, hardcoded string value.\"\n    }\n  }\n}\n</code></pre>"},{"location":"proposals/v0_8/#booleanreferencejson","title":"booleanReference.json","text":"<p>As above, but with:</p> <pre><code>\"literalBoolean\": { \"type\": \"boolean\" }\n</code></pre>"},{"location":"proposals/v0_8/#numberreferencejson","title":"numberReference.json","text":"<p>As above, but with:</p> <pre><code>\"literalNumber\": {\n  \"type\": \"number\"\n}\n</code></pre>"},{"location":"proposals/v0_8/#componentreferencejson","title":"componentReference.json","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/componentReference.json\",\n  \"title\": \"Component Reference\",\n  \"description\": \"A reference to a single component instance by its unique ID.\",\n  \"type\": \"string\"\n}\n</code></pre>"},{"location":"proposals/v0_8/#componentarrayreferencejson","title":"componentArrayReference.json","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/componentArrayReference.json\",\n  \"title\": \"Component Array Reference\",\n  \"description\": \"Defines a list of child components, either explicitly or via a data-bound template.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"explicitList\": {\n      \"type\": \"array\",\n      \"description\": \"An explicit list of component instance IDs.\",\n      \"items\": {\n        \"$ref\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/componentReference.json\"\n      }\n    },\n    \"template\": {\n      \"type\": \"object\",\n      \"description\": \"A template to be rendered for each item in a data-bound list.\",\n      \"properties\": {\n        \"componentId\": {\n          \"type\": \"string\",\n          \"description\": \"The ID of the component (from the main 'components' list) to use as a template for each item.\"\n        },\n        \"dataBinding\": {\n          \"type\": \"string\",\n          \"description\": \"A data binding reference to a list within the data model (e.g., '/user/posts').\"\n        }\n      },\n      \"required\": [\"componentId\", \"dataBinding\"]\n    }\n  }\n}\n</code></pre>"},{"location":"proposals/v0_8/#actionjson","title":"action.json","text":"<pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/google/a2ui/refs/heads/main/schemas/v0.1/action.json\",\n  \"title\": \"Action\",\n  \"description\": \"Represents a user-initiated action.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"action\": {\n      \"type\": \"string\",\n      \"description\": \"A unique name identifying the action (e.g., 'submitForm').\"\n    },\n    \"context\": {\n      \"type\": \"array\",\n      \"description\": \"A key-value map of data bindings to be resolved when the action is triggered.\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"key\": {\n            \"type\": \"string\"\n          },\n          \"value\": {\n            \"type\": \"object\",\n            \"description\": \"The dynamic value. Define EXACTLY ONE of the nested properties.\",\n            \"properties\": {\n              \"path\": {\n                \"type\": \"string\",\n                \"description\": \"A data binding reference to a location in the data model (e.g., '/user/name').\"\n              },\n              \"literalString\": {\n                \"type\": \"string\",\n                \"description\": \"A fixed, hardcoded string value.\"\n              },\n              \"literalNumber\": {\n                \"type\": \"number\"\n              },\n              \"literalBoolean\": {\n                \"type\": \"boolean\"\n              }\n            }\n          }\n        },\n        \"required\": [\"key\", \"value\"]\n      }\n    }\n  },\n  \"required\": [\"action\"]\n}\n</code></pre>"}]}